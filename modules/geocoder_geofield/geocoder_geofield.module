<?php

/**
 * @file
 * Geocoder Geofield module.
 */

use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\geocoder\Geocoder;

/**
 * Implements hook_form_FORM_ID_alter().
 */
function geocoder_geofield_form_field_config_edit_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\field\FieldConfigInterface $field */
  $field = $form_state->getFormObject()->getEntity();
  if ($field->getType() !== 'geofield') {
    return;
  }

  // Use a shortcut for code readability.
  $geocoder =& $form['third_party_settings']['geocoder_geofield'];

  $geocoder['#type'] = 'details';
  $geocoder['#title'] = t('Geocode');
  $geocoder['#open'] = TRUE;

  $geocoder['method'] = [
    '#type' => 'radios',
    '#title' => t('Geocode method'),
    '#options' => [
      'none' => t('No geocoding'),
      'source' => t('Geocode from an existing field'),
      'destination' => t('Reverse geocode from an existing field'),
    ],
    '#default_value' => $field->getThirdPartySetting('geocoder_geofield', 'method', 'none'),
  ];
  $geocoder['field'] = [
    '#type' => 'select',
    '#title' => t('Geocode from an existing field'),
    '#description' => t('Select which field you would like to use.'),
    '#default_value' => $field->getThirdPartySetting('geocoder_geofield', 'field'),
    '#options' => \Drupal::service('geocoder_geofield.manager')->getFields($field->getTargetEntityTypeId(), $field->getTargetBundle(), $field->getName()),
  ];
  $geocoder['plugins'] = [
    '#type' => 'table',
    '#header' => [t('Geocoder plugins'), t('Weight')],
    '#tabledrag' => [[
      'action' => 'order',
      'relationship' => 'sibling',
      'group' => 'plugins-order-weight',
    ]],
    '#caption' => t('Select the Geocoder plugins to use, you can reorder them. The first one to return a valid value will be used.'),
  ];

  $default_plugins = $field->getThirdPartySetting('geocoder_geofield', 'plugins');
  $plugins = array_combine($default_plugins, $default_plugins);
  foreach (\Drupal::service('plugin.manager.geocoder.provider')->getDefinitions() as $plugin_id => $definition) {
    $name = isset($definition['name']) ? $definition['name'] : $plugin_id;
    // Non-default values are appended at the end.
    $plugins[$plugin_id] = $name;
  }
  foreach ($plugins as $plugin_id => $name) {
    $geocoder['plugins'][$plugin_id] = [
      'checked' => [
        '#type' => 'checkbox',
        '#title' => $name,
        '#default_value' => in_array($plugin_id, $default_plugins),
      ],
      'weight' => array(
        '#type' => 'weight',
        '#title' => t('Weight for @title', ['@title' => $name]),
        '#title_display' => 'invisible',
        '#attributes' => ['class' => ['plugins-order-weight']],
      ),
      '#attributes' => ['class' => ['draggable']],
    ];
  }

  $dumpers = [];
  foreach (\Drupal::service('plugin.manager.geocoder.dumper')->getDefinitions() as $plugin_id => $definition) {
    $name = isset($definition['name']) ? $definition['name'] : $plugin_id;
    $dumpers[$plugin_id] = $name;
  }
  $geocoder['dumper'] = [
    '#type' => 'select',
    '#title' => t('Output format'),
    '#default_value' => $field->getThirdPartySetting('geocoder_geofield', 'dumper'),
    '#options' => $dumpers,
    '#description' => t('Set the output format of the value. Ex, for a geofield, the format must be set to WKT.'),
  ];
  $geocoder['delta_handling'] = [
    '#type' => 'select',
    '#title' => t('Multi-value input handling'),
    '#description' => [
      ['#markup' => t('Should geometries from multiple inputs be:')],
      [
        '#theme' => 'item_list',
        '#items' => [
          t('Matched with each input (e.g. One POINT for each address field'),
          t('Aggregated into a single MULTIPOINT geofield (e.g. One MULTIPOINT polygon from multiple address fields)'),
          t('Broken up into multiple geometries (e.g. One MULTIPOINT to multiple POINTs.)'),
        ],
      ]
    ],
    '#default_value' => $field->getThirdPartySetting('geocoder_geofield', 'delta_handling'),
    '#options' => [
      'default' => t('Match Multiples (default)'),
      'm_to_s' => t('Multiple to Single'),
      's_to_m' => t('Single to Multiple'),
      'c_to_s' => t('Concatenate to Single'),
      'c_to_m' => t('Concatenate to Multiple'),
    ],
  ];

  $form['#validate'][] = 'geocoder_geofield_field_config_edit_form_validate';
}

/**
 * Provides an additional form validation callback for 'field_config_edit_form'.
 *
 * @param array $form
 *   A form API form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state object.
 */
function geocoder_geofield_field_config_edit_form_validate(array $form,  FormStateInterface $form_state) {
  // Clean-up and normalize the plugin list.
  $trail = ['third_party_settings', 'geocoder_geofield', 'plugins'];
  $plugins = array_keys(array_filter($form_state->getValue($trail),
    function ($item) {
      return (bool) $item['checked'];
    }
  ));
  $form_state->setValue($trail, $plugins);
}

/**
 * Implements hook_entity_presave().
 */
function geocoder_geofield_entity_presave(EntityInterface $entity) {
  if (!$entity instanceof ContentEntityInterface) {
    return;
  }
  /** @var \Drupal\Core\Entity\ContentEntityInterface $entity */

  /** @var \Drupal\Core\Entity\EntityFieldManager $entity_field_manager */
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $fields = $entity_field_manager->getFieldMapByFieldType('geofield');
  $entity_type_id = $entity->getEntityTypeId();
  if (!isset($fields[$entity_type_id])) {
    return;
  }

  /** @var \Drupal\geocoder\Plugin\GeocoderPluginManager $data_prepare_manager */
  $data_prepare_manager = \Drupal::service('plugin.manager.geocoder.data_prepare');
  $dumper_manager = \Drupal::service('plugin.manager.geocoder.dumper');
  $bundle = $entity->bundle();

  foreach ($fields[$entity_type_id] as $field_name => $info) {
    if (!isset($info['bundles'][$bundle])) {
      // The field $field_name is not in $bundle.
      continue;
    }
    /** @var \Drupal\field\FieldConfigInterface $field_config */
    $field_config = FieldConfig::load("$entity_type_id.$bundle.$field_name");
    $geocode =& $field_config->getThirdPartySettings('geocoder_geofield');

    if (empty($geocode['method']) || $geocode['method'] === 'none') {
      // This field was not configured to geocode from/to other field.
      continue;
    }

    // @todo Check here for malformed $geocode and throw appropriate exceptions.

    $remote_field = $entity->get($geocode['field']);
    // Get the remote field type.
    $type = $remote_field->getFieldDefinition()->getType();

    // @todo Provide a method in manager to return definitions based on $type.
    $definitions = array_filter($data_prepare_manager->getDefinitions(),
      function($definition) use ($type) {
        return in_array($type, $definition['field_types']);
      }
    );

    $values = $remote_field->getValue();
    /** @var \Drupal\geocoder\Plugin\Geocoder\DumperInterface $dumper */
    $dumper = $dumper_manager->createInstance($geocode['dumper']);

    // Prepare data.
    foreach ($definitions as $definition) {
      /** @var \Drupal\geocoder\Plugin\Geocoder\DataPrepareInterface $data_prepare_plugin */
      $data_prepare_plugin = $data_prepare_manager->createInstance($definition['id']);
      $data_prepare_plugin
        ->setEntity($entity)
        ->setGeocoderSettings($geocode)
        ->prepareValues($values);
    }

    $result = array_filter(array_map(function ($value) use ($geocode, $dumper) {
      if ($address_collection = Geocoder::geocode($geocode['plugins'], $value['value'])) {
        return $dumper->dump($address_collection->first());
      }
      return NULL;
    }, $values));
    if (!empty($result)) {
      $entity->set($field_name, $result);
    }
  }
}
